#!/usr/bin/perl

# kmer_search_sites.pl
# A plugin script for kmers.pl which searches for kmers when given a range of binding sites.
# The idea here is that we want to identify which kmers are found in certain genomic ranges to assist with improving kmer set construction.
# Note that this is meant to be a fairly exhaustive process, so the runtime will not scale all that well with larger and larger missing sections.

# Author: MH Seabolt
# Last updated: 6-4-2020

use strict;
use warnings;
use Getopt::Long qw(GetOptions);

use lib '/media/hunter/Data/scripts';
use lib 'D:\scripts';
use lib '/scicomp/home/ngr8/Biolinux/scripts';

# Required input parameters
my $input_sites = "--";
my $output = "--";
my $cfg;
my $v;

sub usage {
	my $usage = "kmer_search_sites.pl\n
	PURPOSE:            A plugin script for kmers.pl which searches for kmers kmers found in certain given genomic ranges to assist with improving kmer set construction.
                        \n
	USAGE: kmer_search_sites.pl [options]
          
	=== INPUT PARAMETERS ===
	-i                       Input binding sites profile, generated by kmers.pl or kmer_profile.pl scripts.

	===SEARCH CONFIGURATION ===
	-search           		The range of kmers to retrieve, given as a:b or a-b. Multiple instructions can be passed as a csv list (or a cfg file, with one interval per line)
							Eg. to find kmers with a binding site between 1500-1550 AND between 2020-2025 AND at site 1733, use -search 1500-1550,2020-2025,1733
	
	=== OUTPUT PARAMETERS ===
	-out                     Output file base name, not including extensions.  
	
	=== OPTIONAL EXTRAS ===
	-v 					verbose
	
	\n";
	print $usage;
}
if ( scalar @ARGV == 0 ) { die usage(); }

GetOptions( 'in|i=s' => \$input_sites,
			'output|o=s' => \$output,
			'search=s' => \$cfg,
			'verbose|v' => \$v,
) or die usage(); 

# Parameter setups
$v = defined($v)? 1 : 0;	

###################################################################
# Read the binding sites and populate a hash
# Be mindful that depending on how the original set of kmers was constructed/filtered, not all sites may be covered.
my $fh = *STDIN;
my $succin = open(SITES, "<", "$input_sites") if ( $input_sites ne "--" && -e $input_sites );
$fh = *SITES if ( $succin );

my %BindingSites = ();
while ( <$fh> )	{
	chomp $_;
	my @line = split("\t", $_);
	my @sites = split(",", $line[1]);
	$BindingSites{ $line[0] } = \@sites;	
}
close SITES if ( $succin );
###################################################################


###################################################################
# The parser for the binding sites requested
my %Cfg = ();
if ( $cfg )	{
	my @raw;
	if ( -e $cfg )	{
		open CGET, $cfg;
			@raw = <CGET>;
		close CGET;
		chomp $_ foreach ( @raw );
	}
	else	{
		@raw = split(",", $cfg);
	}
	die " === KMER SEARCH Error :: Cannot search for anything if you don't tell me where to look! Bad search instructions given! ===\n" if ( scalar @raw == 0 );
	
	# Foreach interval, get the start position and the stop position and store them as a key-value pair in %Cfg.
	# If we only have a single position, start and stop are the same.
	foreach my $config ( @raw )	{
		next if ( $config =~ /Start|Stop/ );
		# If we've got a range of sites
		if ( $config =~ /:|-/ )		{
			my @cols = split(/:|-/, $config);
			my ( $start, $stop ) = ( $cols[0], $cols[1] );
			$stop = $start if ( not $stop );
			( $start, $stop ) = ( $stop, $start ) if ( $stop < $start );
			$Cfg{$start} = $stop;
		}
		else	{
			# If we think we have the format outputted from kmer_coverage.pl (ie. the sections_not_covered.tab file)
			my @line = split("\t", $config);
			if ( scalar @line == 5 )	{
				my ( $start, $stop ) = ( $line[2], $line[3] );
				$stop = $start if ( not $stop );
				( $start, $stop ) = ( $stop, $start ) if ( $stop < $start );
				$Cfg{$start} = $stop;
			}
			# Then assume we just have 1 instruction
			elsif ( scalar @line == 1 )	{
				$Cfg{$config} = $config;
			}
		}
	}
}
###################################################################


###################################################################
# For each site in the range we want to search, grep that value from the hash values
# Briefly, this loop searches the binding sites of each kmer for sites matching the given interval, and returns the kmer
my @kmers;
foreach my $interval_start ( keys %Cfg )	{
	print STDERR " === KMER SEARCH SITES :: Searching for kmers in range $interval_start --> $Cfg{$interval_start} === \n" if ( $v == 1 );
	foreach my $kmer ( keys %BindingSites )		{
		push @kmers, $kmer if ( grep { $_ >= $interval_start && $_ <= $Cfg{$interval_start} } @{$BindingSites{$kmer}} );		
	}
}
###################################################################

###################################################################
# Output the same binding site format that we usually want.
# Note that each kmer is expected to have binding sites outside the only ones that we want, but we have to acknowledge those.
my $succout = open(OUT, ">", "$output.kmers.binding_sites.searched.tab") if ( $output ne "--" );
foreach my $kmer ( @kmers )	{
	if ( $succout ) 	{	print OUT    "$kmer\t", join(",", @{$BindingSites{$kmer}}), "\n";		}
	else 				{	print STDOUT "$kmer\t", join(",", @{$BindingSites{$kmer}}), "\n";		}
}	
close OUT if ( $succout );
###################################################################

exit;