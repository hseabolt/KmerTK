#!/usr/bin/perl

# kmer_statistics.pl
# A plugin script for kmers.pl which calculates the minimum set of kmers required to achieve a threshold value of the Gini evenness index and cover the entire genome.
# Requires CPAN model Set::Scalar for this, we are using these implementations for out set operations API, this script is just a wrapper for that.

# Author: MH Seabolt
# Last updated: 5-10-2020

use strict;
use warnings;
use Getopt::Long qw(GetOptions);
use Cwd qw(cwd);
use List::Util qw(first shuffle uniq any);
use Scalar::Util qw(looks_like_number);
use File::Basename; 

use lib '/media/hunter/Data/scripts';
use lib 'D:\scripts';
use lib '/scicomp/home/ngr8/Biolinux/scripts';

# Required input parameters
my $input_sites = "--";
my $output = "--";
my $convergence_threshold;
my $n_sets;
my $k;
my $p;
my $q;
my $v;
my $max_mean_dist;
my $max_gini;

sub usage {
	my $usage = "kmer_gini.pl\n
	PURPOSE:           A plugin script for kmers.pl which enables Set operations to be calculated from an input data matrix.
					   Compute a requested Set operation between all pairs of columns in the input matrix.
                        \n
	USAGE: kmer_gini.pl [options]
          
	=== INPUT PARAMETERS ===
	-i                       Input binding sites profile, generated by kmers.pl script.

	=== SET CONSTRUCTION OPTIONS ===
	-convergence 			FLOAT; Threshold value of the Gini Index to use to estimate when a given set has reached an acceptable convergence.  Must be between 0 and 1.  [ Default: 0.10 ]
	-n_sets					INT; Number of kmer sets to generate (all passing convergence checks).  [Default: 1]
	-buffer_size			INT; Number of previous Gini indices to save for convergence checks.  [ Default: 3 ]						
	-min_set_size		 	INT; Minimum kmer set size to return [ Default: 2 ]
	-max_set_size 			INT; Maximum kmer set size to return [ Default: no maximum ]
	-max_mean_dist			INT; Maximum mean distance between all kmers in a set [Default: 1,500,000]
	-max_gini				INT; Maximum allowed Gini index for a set of kmers.  Default: 1.00
	
	=== OUTPUT PARAMETERS ===
	-out                     Output file base name, not including extensions.  

							
	=== OPTIONAL EXTRAS ===
	-v 					verbose
	
	\n";
	print $usage;
}
if ( scalar @ARGV == 0 ) { die usage(); }

GetOptions( 'in|i=s' => \$input_sites,
			'convergence=f' => \$convergence_threshold,
			'output|o=s' => \$output,
			'buffer_size|k=i' => \$k,
			'n_sets|n=i' => \$n_sets,
			'min_set_size|p=i' => \$p,
			'max_set_size|q=i' => \$q,
			'max_mean_dist|d=i' => \$max_mean_dist,
			'max_gini=f' => \$max_gini,
			'verbose|v' => \$v,
) or die usage(); 

# Parameter setups
$convergence_threshold = ( $convergence_threshold && $convergence_threshold > 0.0 && $convergence_threshold <= 1.0 )? $convergence_threshold : 0.10;
$n_sets = ( $n_sets && $n_sets >= 1 )? $n_sets : 1;
$max_mean_dist = ( $max_mean_dist && $max_mean_dist > 1 )? $max_mean_dist : 1500000;
$max_gini = ( $max_gini && $max_gini <= 1.0 && $max_gini >= 0.0 )? $max_gini : 1.0;
$k = ( $k && $k >= 1 )? $k : 3;
$p = ( $p && $p >= 1 )? $p : 2;					
$v = defined($v)? 1 : 0;	




given a set of kmers (and binding sites), explicitly calculate the Gini index of this set.
given a set of kmers, decide (yes or no) if the set meets the criteria for a clique in kmer_graph.
expected probability of encountering a given kmer in some genome of size n




sample / resample (with and without replacement)
sample from unwieghted or weighted distribution
build_distribution
expected probability
observed probability
bootstrap
jackknife
histogram

descriptive stats for distributions (mean, median, mode, range, quartiles, 

correlations between two columns (Pearson, Spearman, Kendall)





exit;


################ SUBROUTINES ######################

# Descriptive Statistics 
sub mean	{ 
	return sum(@_)/@_;
}

sub stdev	{
	my @data = @_;
        if ( @data == 1 ) {
                return 0;
        }
        my $mean = mean(@data);
        my $std = 0;
        foreach ( @data ) {
                $std += ( $_ - $mean ) ** 2;
        }
        $std = ( $std / scalar @data ) ** 0.5;
        return $std;
}

sub sum	{
	my ( @numbers ) = @_;
	my $sum = 0;
	
	foreach ( @numbers )	{
		$sum += $_;
	}
	
	return $sum;
}

# Returns the max value from a set of numerical args
sub max 	{
	my (@l) = @_;
	my $max = $l[0];
	foreach my $x ( @l )	{
		$max = $x if ( $x > $max );
	}
	return $max;
}

# Returns the min value from a set of numerical args
sub min	{
	my (@l) = @_;
	my $min = $l[0];
	foreach my $x ( @l )	{
		$min = $x if ( $x < $min );
	}
	return $min;
}

# Returns the median value of an array list
sub median {
    my (@data) = ( scalar @_ == 0 )? return 0 : sort { $a <=> $b } @_;
    if ( scalar(@data) % 2 ) {
        return ( $data[ @data / 2 ] );
    } 
    else {
        my ( $upper, $lower );
        $lower = $data[ @data / 2 ];
        $upper = $data[ @data / 2 - 1 ];
        return ( mean( $lower, $upper ) );
    }
}

# Randomly selects an element from a given array
sub choose	{
	my (@data) = ( scalar @_ == 0 )? return "NA" : @_;
	my $index = int(rand( scalar @data ));
	return $data[$index];
}

# Returns the number of non-empty elements in a given array
sub count	{
	( scalar @_ == 0 )? return 0 : return scalar( grep { defined($_) && $_ > 0 } @_ );
}

# Normalizes a list of numerical values		
sub normalize	{
	my ( $self, $dist ) = @_;
	my $probabilities;
	my $total = sum @{$dist};	
	foreach my $probability ( @{$dist} )	{
		push @{$probabilities}, ($probability/$total);
	}
	return $probabilities;
}

# Randomly select an element from a list and return both the element and the randomly chosen index
sub random_choice	{
	my ( $self, $list ) = @_;
	my $idx = int(rand(scalar @{$list}));
	return ( $list->[$idx], $idx );
}

# This package's way of samnpling a normalized distribution		
sub choose_from_distribution	{
	my ( $self, $dist ) = @_;
	my $rand = rand();			# Gets a random value between 0 and 1
	
	# Return the index of a randomly sampled element in the distribution
	for ( my $p=0; $p < scalar @{$dist}; $p++ )	{
		$rand -= $dist->[$p];
		if ( $rand <= 0 )	{
			return $p;
		}
		# Otherwise, keep going
	}
	# If we got here, then there are problems :)
	warn "Gibbs::choose_from_distribution WARNING: Choosing from a distribution is hard. Did you make sure the distribution was normalised?\n";
	return;
}		

sub sites2distances 	{
	my ( @sites ) = sort { $a <=> $b } @_;
	my @distances;
	for ( my $d=1; $d < scalar @sites; $d++ )	{
		my $f = $d - 1;
		push @distances, $sites[$d] - $sites[$f]; 	# The current element minus the previous element
	}
	return @distances;
}


# Calculates the Gini coefficient from a 1D list of non-negative, ascending sorted numbers
# The index ranges from 0 to 1, with values approaching 1 indicating increasing unevenness (we want a value close to 0)
sub gini_index		{
	my ( @distances ) = @_;
	@distances = sort { $a <=> $b } @distances;
	my $n = scalar @distances;
	my $sum = sum( @distances );
	my $gini_index;
	for ( my $i=0; $i < $n; $i++ )	{
		$gini_index += ((2*($i  +1) - $n - 1) * $distances[$i]) / ($n * $sum);		# Function described: https://github.com/oliviaguest/gini
	}
	return sprintf("%1.3f", $gini_index);
}