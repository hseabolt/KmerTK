#!/usr/bin/perl

# kmer_coverage.pl
# A plugin script for kmers.pl which estimates the breadth coverage of the genome, given a set of kmers and their binding sites.
# The intention here is that we can readily identify regions of the genome that are not covered very well and that we want to 
# capture by revisiting the set construction.

# Currently, the variance and range parameters are estimated using an approximated Normal distribution and reported values for Phi29 DNA polymerase,
# commonly used in MDA and WGA reactions in laboratories.  Ideally, one should empirically determine these parameters using their preferred
# methods of DNA extraction followed by a BioAnalyzer run to determine fragment size to start.  THEN, perform MDA and measure fragment sizes 
# again using a BioAnalyzer to help predict these values.

# This script is expecting the input in the format written out by kmer_gini.pl
# Set#		NKmers		NSites		MeanDist	SetGini		Kmers(csv)  	BindingSites(sorted csv)

# Author: MH Seabolt
# Last updated: 5-27-2020

use strict;
use warnings;
use Getopt::Long qw(GetOptions);
use Cwd qw(cwd);
use List::Util qw(first shuffle uniq any);
use Scalar::Util qw(looks_like_number);
use File::Basename; 

use lib '/media/hunter/Data/scripts';
use lib 'D:\scripts';
use lib '/scicomp/home/ngr8/Biolinux/scripts';

# Required input parameters
my $input_sites = "--";
my $output = "--";
my $genome_fasta;
my $sd;
my $max_range;
my $tiers_range;
my $v;

sub usage {
	my $usage = "kmer_coverage.pl\n
	PURPOSE:           	A plugin script for kmers.pl which computes predicted breadth coverage of a genome given a set of binding sites from kmer_gini.pl
                        \n
	USAGE: kmer_coverage.pl [options]
          
	=== INPUT PARAMETERS ===
	-i                      	Input sets file, generated by kmer_gini.pl script.
	-g 				The original genome FASTA file used to produce the kmer profile and binding sites data.

	=== SET CONSTRUCTION OPTIONS ===
	-max_range			INT; The maximum extention range of the given DNA polymerase.  For Phi29 polymerase, this value would be 70,000 [Default]. 
	-stdev 				INT; An estimated stadard deviation value for an approximated Normal distribution of amplicons lengths produced by the given DNA polymerase. [Default: 11,900]
	
	=== OUTPUT PARAMETERS ===
	-out                    	Output file base name, not including extensions.  Output is in GFF format.
	-tiers			 	The range of tiers that we want to keep.  Eg: -tiers 0,1
	
	=== OPTIONAL EXTRAS ===
	-v 				Verbose
	
	\n";
	print $usage;
}
if ( scalar @ARGV == 0 ) { die usage(); }

GetOptions( 'in|i=s' => \$input_sites,
			'output|o=s' => \$output,
			'genome_fasta|g=s' => \$genome_fasta,
			'max_range|r=i' => \$max_range,
			'stdev=i' => \$sd,
			'tiers=s' => \$tiers_range,
			'verbose|v' => \$v,
) or die usage(); 

# Parameter setups
die " === KMER COVERAGE Error :: Can't locate your genome FASTA file! === \n" unless ( -e $genome_fasta );
$v = defined($v)? 1 : 0;	
$sd = ( $sd && $sd > 0 )? $sd : 11900;			
$max_range = ( $max_range && $max_range > 0 )? $max_range : 70000;	

###################################################################
# The parser for the tiers -- this is a terrible parser, but its very small, so I dont care :)
my %Tiers = ( '0' => 0, '1', => 0, '2' => 0, '3' => 0, '4' => 0 );
if ( $tiers_range )	{
	if ( $tiers_range =~ /all/ )	{	$Tiers{$_} = 1 foreach ( keys %Tiers );		}
	else	{
		my @range = split(",", $tiers_range);
		foreach my $config ( @range )	{
			# If we've got a range
			if ( $config =~ /:|-/ )		{
				my @ranks = split(/:|-/, $config);
				my ( $start, $stop ) = ( $ranks[0], $ranks[1] );
				for ( my $i=$start; $i <= $stop; $i++ )	{
					my @key = grep { $_ =~ /^$i/ } keys %Tiers;
					$Tiers{$key[0]} = 1;
				}
			}
			else	{
				my @key = grep { $_ =~ /^$config/ } keys %Tiers;
				$Tiers{$key[0]} = 1;
			}
		}
	}
}
# Otherwise, assume we just want the distances from one binding site to the next
else	{
	$Tiers{0} = 1;
}
# The following algorithm only wants the tiers we are goign to use, so for expediency, delete the ones we dont want here.
foreach ( keys %Tiers )	{
	delete $Tiers{$_} if ( $Tiers{$_} == 0 );
}
###################################################################


###################################################################
# Read the binding sites and populate a hash
my $fh = *STDIN;
my $succin = open(SITES, "<", "$input_sites") if ( $input_sites ne "--" && -e $input_sites );
$fh = *SITES if ( $succin );

# Get the set of contig/chromosome intervals
my ( $M ) = get_fasta_lengths( $genome_fasta );
my $total_length = $M->[-1]->[-1];

# Open the output and write the headers
my ( $succout ) = open(RANGES, ">", "$output.ranges.gff");
if ( $succout )			{ 	
	print RANGES "# Genome fasta: $genome_fasta\n";
	print RANGES "# Input binding sites: $input_sites\n";
	print RANGES "# Note: Start/Stop coordinates are 1-based, and inclusive to both positions.\n";
	print RANGES "# Chrom\tSource\tFeature\tStart\tEnd\tScore\tStrand\tPhase\tAttributes\n";
}

# Additionally, define the range of the sites covered by the given kmer set (expected to be smaller than the complete genome)
# This parser is expecting the input in the format written out by kmer_gini.pl, one set per line in the following TAB format, but as long as the last field is a csv list of sites, we are happy.
# Set#		NKmers		NSites		MeanDist	SetGini		Kmers(csv)  	BindingSites(sorted csv)
my @all_sites;
my @results;
while ( <$fh> )	{
	chomp $_;
	next if ( $_ =~ /^#/ || $_ !~ /[\S]/ || ($. == 1 && $_ =~ /Kmer/) );		# Skip the first line if it looks like a header (and it should, coming from kmer_gini.pl), or if it looks like a comment/blank line
	my @line = split("\t", $_);
	my @sites = split(",", $line[-1]);
	@sites = sort { $a <=> $b } @sites; 
	my $name = $line[0];		# Better hope this isnt the binding sites ;)
	
	for ( my $i=0; $i < scalar @sites; $i++ )	{
		my $site = $sites[$i];
		my ( $contig, $site_coord ) = chrom_coordinates( $site, $M );
		if ( $succout )		{	print RANGES "$contig\tkmer_coverage.pl\tsite\t", $site_coord+1, "\t", $site_coord+1, "\t.\t+\t.\tset=$name;tier=NA;covered=NA;size=1\n";	}
		else				{	print STDOUT "$contig\tkmer_coverage.pl\tsite\t", $site_coord+1, "\t", $site_coord+1, "\t.\t+\t.\tset=$name;tier=NA;covered=NA;size=1\n";	}
	}
	
	# For each binding site, transform it into a genomic interval with the "mean" value at the exact binding location, the variance that we already calculated, and the flanking range based on the polymerase range
	# We can even account for the confidence in each interval by setting the levels of confidence as standard deviations from the mean (assuming an approximated Normal distribution-like pattern).
	# We are assuming a rather fat and somewhat flat distribution since a Standard Normal approximation.
	foreach my $tier ( sort {$a <=> $b } keys %Tiers ) 	{
	
		# Calculate the tiered intervals from the max range and standard deviation.
		# The tiers progress from lowest confidence (tier 3) up to highest (tier 1), where the tier is the number of standard deviations from the binding site 'mean'.  
		# Tier 0 are the binding sites themselves.
		my %Intervals = ();
		my @Coords;
		for ( my $i=0; $i < scalar @sites; $i++ )	{
			my $site = $sites[$i];

			# The start site for each interval (the hash key) is the greater of either the starting position of the interval or 0, the beginning of the genome.
			# The ending site of the interval, the hash value, is the lesser of either the interval's ending position or the maximum position in the genome.
			my $start_site = ($site - ($tier*$sd) > 0)? $site - ($tier*$sd) : 0;
			$Intervals{$start_site} = (($site + ($tier*$sd)) < $total_length )? ($site + ($tier*$sd)) : $total_length;
			
			###############################################################################
			# Compute and print the genomic ranges, save them in the @Coords matrix
			my ( $contig, $site_coord ) = chrom_coordinates( $site, $M );
			my ( $start_contig, $start_coord ) = chrom_coordinates( $start_site, $M );
			my ( $stop_contig, $stop_coord ) = chrom_coordinates( $Intervals{$start_site}, $M );

			# Check that we dont span a contig break --> adjust if we do.
			$start_coord = 0 if ( $start_contig ne $contig );
			if ( $stop_contig ne $contig )	{
				for ( my $i=0; $i < scalar @{$M}; $i++ )	{
					if ( $M->[$i]->[0] eq $contig )		{
						$stop_coord = chrom_coordinates( $M->[$i]->[2], $M );
						last;
					}
				}
			}
			$Coords[$i] = [ $contig, $start_coord, $stop_coord ];
			
			# Print the binding site and the ranges that ARE covered
			if ( $succout )		{
				print RANGES "$contig\tkmer_coverage.pl\trange\t1\t", $start_coord+1, "\tset=$name;tier=$tier;covered=true;site=", $site_coord+1, ";size=", $start_coord+1, ";\n" if ( $i == 0 && $start_coord > 0 );		# Dont print this line if there is a contig jump in the first range
				print RANGES "$contig\tkmer_coverage.pl\trange\t", $start_coord+1, "\t", $stop_coord+1, "\t.\t+\t.\tset=$name;tier=$tier;covered=true;site=", $site_coord+1, ";size=", $stop_coord - $start_coord, ";\n";
				if ( $i+1 == scalar @sites )	{
					my ($end_contig, $end_coord) = chrom_coordinates( $M->[-1]->[-1], $M );
					print RANGES "$contig\tkmer_coverage.pl\trange\t", $stop_coord+1, "\t", $end_coord+1, "\tset=$name;tier=$tier;covered=true;site=", $site_coord+1, ";size=", $end_coord - $stop_coord, ";\n" if ( $end_contig eq $contig && $stop_coord < $end_coord );	# Dont print this line if there is a contig jump in the last range
				}
			}
			else		{
				print STDOUT "$contig\tkmer_coverage.pl\trange\t1\t", $start_coord+1, "\tset=$name;tier=$tier;covered=true;site=", $site_coord+1, ";size=", $start_coord+1, ";\n" if ( $i == 0 && $start_coord > 0 );		# Dont print this line if there is a contig jump in the first range
				print STDOUT "$contig\tkmer_coverage.pl\trange\t", $start_coord+1, "\t", $stop_coord+1, "\t.\t+\t.\tset=$name;tier=$tier;covered=true;site=", $site_coord+1, ";size=", $stop_coord - $start_coord, ";\n";
				if ( $i+1 == scalar @sites )	{
					my ($end_contig, $end_coord) = chrom_coordinates( $M->[-1]->[-1], $M );
					print STDOUT "$contig\tkmer_coverage.pl\trange\t", $stop_coord+1, "\t", $end_coord+1, "\tset=$name;tier=$tier;covered=true;site=", $site_coord+1, ";size=", $end_coord - $stop_coord, ";\n" if ( $end_contig eq $contig && $stop_coord < $end_coord );	# Dont print this line if there is a contig jump in the last range
				}
			}
			###############################################################################
		}
		
		# The @Coords matrix is already sorted in the correct order, so we can loop through it to calculate the bases covered plus any overlaps
		# Each row in @Coords = [ contig, startpos, endpos ]
		my $bases_covered = $total_length;
		for ( my $i=1; $i < scalar @Coords; $i++ )	{
			
			# If we are on the same contig and there is some overlap between two consecutive intervals (excluding the first interval, which cant overlap with the non-existent previous one)
			my $overlap =  0;
			if ( ($Coords[$i]->[0] eq $Coords[$i-1]->[0]) && ($Coords[$i]->[1] < $Coords[$i-1]->[2]) )		{
				$overlap = abs($Coords[$i]->[1] - $Coords[$i-1]->[2]);
			}
			
			# If no overlap and we want to print out this interval, do that.
			# We have to convert here from Perl's 0-based indexing system to the GFF 1-based indexing, which is weird, so be mindful of off-by-one errors here
			# $Size is calculated from the original coordinates in perl
			# Do we span a contig break?  Need to print out TWO lines (the last on first contig, then first on second contig)
			else	{
				if ( $Coords[$i]->[0] ne $Coords[$i-1]->[0] )		{
					my $contigbreak_end; my $contigbreak_start; my $contig_break;
					for ( my $j=0; $j < scalar @{$M}; $j++ )	{
						# Print the range to the end of the first contig
						if ( $M->[$j]->[0] eq $Coords[$i-1]->[0] )		{
							($contig_break, $contigbreak_end ) = chrom_coordinates( $M->[$j]->[2], $M );
							my $size = $contigbreak_end - $Coords[$i-1]->[2];
							next if ( $size == 0 );	
							if ( $succout ) 	{	print RANGES "$Coords[$i-1]->[0]\tkmer_coverage.pl\trange\t", $Coords[$i-1]->[2] +1, "\t", $contigbreak_end - 1, "\t.\t+\t.\tset=$name;tier=$tier;covered=false;size=", $size, ";\n";	}
							else 				{	print STDOUT "$Coords[$i-1]->[0]\tkmer_coverage.pl\trange\t", $Coords[$i-1]->[2] +1, "\t", $contigbreak_end - 1, "\t.\t+\t.\tset=$name;tier=$tier;covered=false;size=", $size, ";\n";	}
							$bases_covered -= $size;
						}
						
						elsif ( $M->[$j]->[0] eq $Coords[$i]->[0] )		{
							($contig_break, $contigbreak_start ) = chrom_coordinates( $Coords[$i]->[1], $M );
							my $size = $contigbreak_start;
							next if ( $size == 0 );
							if ( $succout )		{	print RANGES "$Coords[$i]->[0]\tkmer_coverage.pl\trange\t1\t", $contigbreak_start-1, "\t.\t+\t.\tset=$name;tier=$tier;covered=false;size=", $size+1, ";\n";		}
							else				{	print STDOUT "$Coords[$i]->[0]\tkmer_coverage.pl\trange\t1\t", $contigbreak_start-1, "\t.\t+\t.\tset=$name;tier=$tier;covered=false;size=", $size+1, ";\n";		}
							$bases_covered -= $size;
						}
					}
				}
			
				# Elsewise, we are on the same contig, but have a gap in coverage.
				else	{
					my $size = $Coords[$i]->[1] - $Coords[$i-1]->[2];
					next if ( $size == 0 );
					if ( $succout )		{	print RANGES "$Coords[$i]->[0]\tkmer_coverage.pl\trange\t", $Coords[$i-1]->[2] + 2, "\t", $Coords[$i]->[1], "\t.\t+\t.\tset=$name;tier=$tier;covered=false;size=", ($Coords[$i]->[1]) - ($Coords[$i-1]->[2] + 2), ";\n";	}
					if ( $succout )		{	print STDOUT "$Coords[$i]->[0]\tkmer_coverage.pl\trange\t", $Coords[$i-1]->[2] + 2, "\t", $Coords[$i]->[1], "\t.\t+\t.\tset=$name;tier=$tier;covered=false;size=", ($Coords[$i]->[1]) - ($Coords[$i-1]->[2] + 2), ";\n";	}
					$bases_covered -= $size;
				}
			}
		}

		# Finally, compute the expected breadth coverage, as a percentage of the genome length covered by non-overlapping intervals.
		my $breadth = sprintf("%5.2f", 100 *  ( $bases_covered / $total_length ));
		
		# Print the results out for each tier, for each set of binding sites
		push @results, "# $name\t$tier\t$bases_covered\t$breadth";
	}
}
close SITES if ( $succin );

# Print the final calculated results at the end of the file
if ( $succout )		{	print RANGES "\n\n# Set\tTier\tTotalBases\tBreadth\n";		}
else				{	print STDOUT "\n\n# Set\tTier\tTotalBases\tBreadth\n";		}
foreach my $line ( @results )	{
	if ( $succout )		{	print RANGES "$line\n";		}
	else				{	print STDOUT "$line\n";		}
}
close RANGES if ( $succout );
###################################################################

exit;

########################## SUBROUTINES ##############################

# Read an input fasta file and return a matrix containing 3 columns -> [ chrom, start, end ]
sub get_fasta_lengths		{
	my ( $file ) = @_;
	
	# Read the data
	my @fastas;
	$/ = ">";
	open FASTA, "$file" or die " ==== KMER COVERAGE Error :: Cannot read the given Fasta file! ===\n$!\n";
		@fastas = <FASTA>;
		my $trash = shift @fastas;	# Get rid of the first element, which will be a lone ">" symbol
	$/ = "\n";

	# Build the matrix
	my @M = [ ];
	my $total_length = 0;
	for ( my $i=0; $i < scalar @fastas; $i++ )	{
		my $record = $fastas[$i];
		my ($header, @seq) = split "\n", $record;
		my $sequence = join '', @seq;
		
		# Store the positions, then update total length
		# We do make a correction here to avoid off-by-one errors in the indexing for all $i greater than 0
		$M[$i] = ( $i > 0 )? [ $header, $total_length + 1, $total_length + length $sequence ] : [ $header, $total_length, $total_length + length $sequence ];
		$total_length += length $sequence;
	}
	return \@M;
}

# Convert a linearized coordinate to it's chromosomal (contig) equivalent coordinate --> assumes 5'->3' orientation.
sub chrom_coordinates	{
	my ( $site, $M ) = @_;
	my $contig;
	my $coord;
	for ( my $i=0; $i < scalar @{$M}; $i++ )	{
		# Advance if our site is greater than the endpoint of the contig in row $i
		next if ( $site > $M->[$i]->[2] );
		
		# If we make it here, then we are on the correct contig
		$contig = $M->[$i]->[0];
		
		# Get the correct position on this contig, which is the site minus the start position of the contig
		$coord = $site - $M->[$i]->[1];

		# Break the loop --> there is no need to continue if we have the coordinate we need
		last;		
	}
	return ( $contig, $coord );
}




