#!/usr/bin/perl

# kmer_random_gini.pl
# A plugin for the kmer_gini.pl plugin.  This script generates random sets and computes the gini index for the set.
# This is generally intended to be used to generate random values for plotting figures and computing statistics.

# Author: MH Seabolt
# Last updated: 11-24-2020

use v5.24.1;
use strict;
use warnings;
use Getopt::Long qw(GetOptions);

use lib '/media/hunter/Data/scripts';
use lib 'D:\scripts';
use lib '/scicomp/home/ngr8/Biolinux/scripts';

# Required input parameters
my $input_sites = "--";
my $output = "--";
my $n_trials;
my $k = 1;
my $p;
my $q;
my $v;
my $max_mean_dist;
my $max_gini;
my $include;
my $step;
my $metrics_only;

sub usage {
	my $usage = "kmer_random_gini.pl\n
	PURPOSE:          	A plugin script for kmers.pl which calculates the minimum set of kmers required to achieve a threshold value of the Gini evenness index and cover the entire genome.

                        \n
	USAGE: kmer_gini.pl [options]
          
	=== INPUT PARAMETERS ===
	-i                     	Input binding sites profile, generated by kmers.pl script.
	-include		A list of mandatory kmers that must be included in set construction, given either as a CSV list or a file with one kmer per line.  The algorithm will build sets around these.

	
	=== SET CONSTRUCTION OPTIONS ===
	-max_mean_dist		INT; Maximum mean distance between all kmers in a set [Default: 1,500,000]
	-max_gini		FLOAT; Maximum allowed Gini index for a set of kmers.  Default: 1.00
	
	
	=== RANDOMIZATION PARAMETERS ===
	-min_set_size		INT; Minimum kmer set size [ Default: 1 ]
	-max_set_size 		INT; Maximum kmer set size [ Default: no maximum ] --> Beware that you will run for literal years if you neglect to set this to a reasonable number!
	-step				INT; Step size for the set size loops [ Default: 1 ]
	-n_trials			INT; Number of kmer sets (=trials) to generate for each given set size.  [Default: 10]
	
	
	=== OUTPUT PARAMETERS ===
	-out                    Output file base name, not including extensions.  
			
			
	=== OPTIONAL EXTRAS ===
	-v 				verbose
	-metrics_only	Do not output the list of kmers or binding sites in the output report [ Default: OFF ]	
	
	\n";
	print $usage;
}
if ( scalar @ARGV == 0 ) { die usage(); }

GetOptions( 'in|i=s' => \$input_sites,
			'output|o=s' => \$output,
			'n_trials|n=i' => \$n_trials,
			'min_set_size|p=i' => \$p,
			'max_set_size|q=i' => \$q,
			'max_mean_dist|d=i' => \$max_mean_dist,
			'max_gini=f' => \$max_gini,
			'verbose|v' => \$v,
			'metrics_only' => \$metrics_only,
			'step|r=i' => \$step,
			'include=s' => \$include,
) or die usage(); 

# Parameter setups
$n_trials = ( $n_trials && $n_trials >= 1 )? $n_trials : 10;
$max_mean_dist = ( $max_mean_dist && $max_mean_dist > 1 )? $max_mean_dist : 1500000;
$max_gini = ( $max_gini && $max_gini <= 1.0 && $max_gini >= 0.0 )? $max_gini : 1.0;
$p = ( $p && $p >= 1 )? $p : 1;		# The default parameters for $q are below	
$v = defined($v)? 1 : 0;									
$metrics_only = defined($metrics_only)? 1 : 0;

###########################################################
#       PHASE 0: Preprocess input data
###########################################################

# Read the binding sites and populate a hash
my $fh = *STDIN;
my $succin = open(SITES, "<", "$input_sites") if ( $input_sites ne "--" && -e $input_sites );
$fh = *SITES if ( $succin );

my %BindingSites = ();
while ( <$fh> )	{
	chomp $_;
	my @line = split("\t", $_);
	my @sites = split(",", $line[1]);
	$BindingSites{ $line[0] } = \@sites;	
}
close SITES if ( $succin );
$q = ( $q && $q <= scalar keys %BindingSites )? $q : scalar keys %BindingSites;		

########################################################################
#       PHASE 1: A randomized version of the Kmer-Gini algorithm
########################################################################

my $succout = open(OUT, ">", "$output.kmer_random_gini.tab") if ( $output ne "--" );
if ( $metrics_only )	{
	if ( $succout ) 	{ 	print OUT    "Trial\tNKmers\tNSites\tMeanDist\tGini\tBernoulli\n";		}
	else				{	print STDOUT "Trial\tNKmers\tNSites\tMeanDist\tGini\tBernoulli\n";		}
}
else	{
	if ( $succout ) 	{ 	print OUT    "Trial\tNKmers\tNSites\tMeanDist\tGini\tBernoulli\tKmers\tBindingSites\n";		}
	else				{	print STDOUT "Trial\tNKmers\tNSites\tMeanDist\tGini\tBernoulli\tKmers\tBindingSites\n";		}
}
open(LOG, ">", "$output.kmer_random_gini.log") if ( $v == 1 );

# Set up any kmers that are required to be included in the randomly generated sets, if we have them
my %Include = ();
if ( $include )	{
	if ( -e $include )	{
		open INCLUDE, "$include" or warn " --- KMER GINI Error :: I cant include sites that you didn't give me (as a file)\n$!\n";
			my @must_include = <INCLUDE>;
		close INCLUDE;
		foreach ( @must_include )	{
			chomp $_;
			my @line = split("\t", $_);
			$Include{ $line[0] } = $BindingSites{ $line[0] };
		}
	}
	else	{
		my @must_include = split(",", $include);
		$Include{$_} = $BindingSites{$_} foreach ( @must_include );	
	}
}

# For each trial at a given set size, generate a new set of kmers and add it to the list of found sets
# This is a nested loop with the outer loop coding for the stepping size of the sets, and the inner loop doing the calculations
for ( my $i=$p; $i <= $q; $i+=$step )	{			# Note: --> if you want to test just a discrete list of values, change this line to foreach my $i ( <values> )	{
	for ( my $a=1; $a <= $n_trials; $a++ )	{
		my @primer_sets;
		my ( $mean_dist, $set_gini, $set ) = kmer_random_gini( \%Include, $i );
		next if ( not $set );
		
		# Separate out the kmer set and all the binding sites
		my @set = keys %{$set};
		push @primer_sets, \@set if ( @set );
		
		# The final Gini index and the binding sites
		my @sites; 
		@sites = ( @sites, @{$_} ) foreach ( values %{$set} );
		
		# Decide if this trial is considered a "success" --> meaning, is the set Gini at or below the convergence threshold?
		# These are encoded as Bernoulli trials encoded by 1 for a success and 0 for a failure
		my $bernoulli = ( $mean_dist <= $max_mean_dist && $set_gini <= $max_gini )? 1 : 0;
		
		# Print the output as we go
		if ( $metrics_only )	{
			if ( $succout )		{ 	print OUT    "$i-$a\t", scalar @set, "\t", scalar @sites, "\t$mean_dist\t$set_gini\t$bernoulli\n";		}
			else				{ 	print STDOUT "$i-$a\t", scalar @set, "\t", scalar @sites, "\t$mean_dist\t$set_gini\t$bernoulli\n";		}
		}
		else	{
			if ( $succout )		{ 	print OUT    "$i-$a\t", scalar @set, "\t", scalar @sites, "\t$mean_dist\t$set_gini\t$bernoulli\t", join(",", @set), "\t", join(",", @sites), "\n";		}
			else				{ 	print STDOUT "$i-$a\t", scalar @set, "\t", scalar @sites, "\t$mean_dist\t$set_gini\t$bernoulli\t", join(",", @set), "\t", join(",", @sites), "\n";		}
		}
	}
}
close OUT if  ( $succout );
exit;

######################################## SUBROUTINES ######################################################

# Arithmetic Mean
sub mean	{ 
	return int sum(@_)/@_;
}

sub sum	{
	my ( @numbers ) = @_;
	my $sum = 0;
	foreach ( @numbers )	{	$sum += $_;		}
	return $sum;
}

sub sites2distances 	{
	my ( @sites ) = @_;
	@sites = sort { $a <=> $b } @sites;
	my @distances;
	for ( my $d=1; $d < scalar @sites; $d++ )	{
		my $f = $d - 1;
		push @distances, $sites[$d] - $sites[$f]; 	# The current element minus the previous element
	}
	return @distances;
}


# Calculates the Gini coefficient from a 1D list of non-negative, ascending sorted numbers
# The index ranges from 0 to 1, with values approaching 1 indicating increasing unevenness (we want a value close to 0)
sub gini_index		{
	my ( @distances ) = @_;
	@distances = sort { $a <=> $b } @distances;
	my $n = scalar @distances;
	my $sum = sum( @distances );
	my $gini_index;
	for ( my $i=0; $i < $n; $i++ )	{
		$gini_index += ((2*($i  +1) - $n - 1) * $distances[$i]) / ($n * $sum);		# Function described: https://github.com/oliviaguest/gini
	}
	return sprintf("%1.3f", $gini_index);
}

# The Kmer-Gini algorithm
sub kmer_random_gini	{
	my ( $included_sites, $size ) = @_;
	
	# Initialize an empty set S, which will hold the kmers in the set, and an empty array of distances D, which will store all of the combined distances
	my %S = ();  
	my @D = ();
	my @convergence = ();
	my @distances = ();
	my $gini = 1.0;
	my $mean; 
	
	# If we have pre-set sites that must be included:
	if ( $included_sites && scalar keys %{$included_sites} > 0 )	{
		%S = %{$included_sites};
		@D = ( @D, @{$_} ) foreach ( values %S );
		@distances = sites2distances( @D );
		$gini = gini_index( @distances );
		$mean = mean( @distances );
	}

	# Some counters
	my $x = 0;
	my $max = scalar keys %BindingSites;
	print STDERR "$i-$x\t$gini\n" if ( $v == 1 );
	
	# Add the first Gini score to the list of gini scores.
	# This list will act as a buffer for the last k updated 
	# Gini scores and will be used to estimate convergence of the algorithm.
	push @convergence, $gini;

	# Recursion:
	# While we have not achieved convergence of Gini indices, continue to add kmers to the set S until we do.
	while ( scalar keys %S < $size )	{
	
		#Choose next kmer to add to %S, check that it isnt already in S
		my $kmer = (keys %BindingSites)[rand keys %BindingSites];
		next if ( exists $S{$kmer} );
		my @E = ( @D, @{$BindingSites{$kmer}} );
		
		# Recalculate the Gini index for the updated @D
		@distances = sites2distances(@E);
		$mean = mean( @distances );
		$gini = gini_index( @distances );
		
		# Skip if we calculate a worse Gini index than previously
		$x++;
		last if ( $x == $max );	
		#next if ( $gini > $convergence[-1] );			# --> have removed this line to allow purely random set construction that is not constrained to produce increasingly more even sets
		
		# Add the chosen kmer to %S, add the distances to @D
		$S{$kmer} = $BindingSites{$kmer};
		delete $BindingSites{$kmer};
		@D = @E;
		print LOG    scalar keys %S, "\t$gini\t$mean\n" if ( $v == 1 );
		print STDERR "$i-", scalar keys %S, "\t$gini\t$mean\n" if ( $v == 1 );
		$x = 0;
	}
	
	# Restore the keys in %S to %BindingSites
	$BindingSites{$_} = $S{$_} foreach ( keys %S );
	
	# Final checks and return
	return ( $mean, $gini, \%S );
}

