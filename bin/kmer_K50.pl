#!/usr/bin/perl

# kmer_K50.pl
# A plugin script for kmers.pl which estimates which kmers are the most 'important' to a set, using a similar metric to genome assembly's L50 score.

# Author: MH Seabolt
# Last updated: 5-27-2020

use strict;
use warnings;
use Getopt::Long qw(GetOptions);

use lib '/media/hunter/Data/scripts';
use lib 'D:\scripts';
use lib '/scicomp/home/ngr8/Biolinux/scripts';

# Required input parameters
my $input;
my $input_sites = "--";
my $output = "--";
my $genome_fasta;
my $sd;
my $tiers_range;
my $v;
my $percentage;

sub usage {
	my $usage = "kmer_coverage.pl\n
	PURPOSE:           A plugin script for kmers.pl which estimates which kmers are the most 'important' to a set, using a similar metric to genome assembly's L50 score.
					This script does have the option of using the same tiered confidence system used by kmer_coverage.pl
                        \n
	USAGE: kmer_coverage.pl [options]
          
	=== INPUT PARAMETERS ===
	-i                      Input sets file, generated by kmer_gini.pl script.
	-b 						Input binding sites profile from kmers.pl. 
	-g 				 		The original genome FASTA file used to produce the kmer profile and binding sites data.

	=== EVALUATION OPTIONS ===
	-stdev 				INT; An estimated stadard deviation value for an approximated Normal distribution of amplicons lengths produced by the given DNA polymerase. [Default: 11,900]
	-percentage 		INT; What is the minimal percentage of the genome breadth that you want to cover?  [Default: 50]
	
	=== OUTPUT PARAMETERS ===
	-out                    Output file base name, not including extensions.  
	-tiers			 		The range of tiers that we want to keep.  Eg: -tiers 0,1
	
	=== OPTIONAL EXTRAS ===
	-v 					verbose
	
	\n";
	print $usage;
}
if ( scalar @ARGV == 0 ) { die usage(); }

GetOptions( 'in|i=s' => \$input,
			'sites|b=s' => \$input_sites,
			'output|o=s' => \$output,
			'genome_fasta|g=s' => \$genome_fasta,
			'stdev=i' => \$sd,
			'tiers=s' => \$tiers_range,
			'percentage=i' => \$percentage, 		# The percentage of the genome we want to minimally cover
			'verbose|v' => \$v,
) or die usage(); 

# Parameter setups
die " === KMER K50 Error :: Can't locate your genome FASTA file! === \n" unless ( -e $genome_fasta );
$v = defined($v)? 1 : 0;	
$sd = ( $sd && $sd > 0 )? $sd : 11900;	
$percentage = ( $percentage && $percentage >= 0 && $percentage <= 100 )? $percentage : 50;

###################################################################
# Read the binding sites and populate a hash
my $fh = *STDIN;
my $succin = open(SITES, "<", "$input_sites") if ( $input_sites ne "--" && -e $input_sites );
$fh = *SITES if ( $succin );
print STDERR " === KMER K50 :: Reading binding sites === \n" if ( $v == 1 );

my %BindingSites = ();
while ( <$fh> )	{
	chomp $_;
	my @line = split("\t", $_);
	my @sites = split(",", $line[1]);
	$BindingSites{ $line[0] } = \@sites;	
}
close SITES if ( $succin );
###################################################################

###################################################################
# Get the input data
my @input_data;
my @names;
my @sets;
print STDERR " === KMER K50 :: Parsing input kmers === \n" if ( $v == 1 );
if ( -e $input ) 	{
	open IN, $input;
		@input_data = <IN>;
	close IN;
}
else 	{
	@input_data = split(";", $input);
}
# Parse in the list of kmers in the set --> assuming that we are going to be using the standard format from kmer_gini.pl and/or kmer_graph.pl
foreach my $line ( @input_data )	{
	chomp $line;
	my @line = split("\t", $line);
	next if ( $line =~ /^#/ || $line !~ /[\S]/ || $line[-2] =~ /Kmers/ );

	# If we appear to have input from kmer_gini.pl
	if ( scalar @line == 7 ) {
		push @names, $line[0];		# The first field should be the name of the set.
		my @set = split(",", $line[-2]);
		push @sets, \@set;
	}
	# If it looks like we are coming from kmer_graph.pl
	elsif ( scalar @line == 3 )	{
		push @names, $line[0];
		my @set = split(",", $line[-1]);
		push @sets, \@set;
	}
	# If we just have a simple csv list of kmers with no name
	elsif ( scalar @line == 1 )		{
		my @set = split(",", $line[0]);
		die if ( not exists $BindingSites{$set[0]} );
		push @sets, \@set;
		push @names, "Set1";
	}
}
###################################################################

###################################################################
# The parser for the tiers -- this is a terrible parser, but its very small, so I dont care :)
my %Tiers = ( '0' => 0, '1', => 0, '2' => 0, '3' => 0, '4' => 0 );
if ( $tiers_range )	{
	if ( $tiers_range =~ /all/ )	{	$Tiers{$_} = 1 foreach ( keys %Tiers );		}
	else	{
		my @range = split(",", $tiers_range);
		foreach my $config ( @range )	{
			# If we've got a range
			if ( $config =~ /:|-/ )		{
				my @ranks = split(/:|-/, $config);
				my ( $start, $stop ) = ( $ranks[0], $ranks[1] );
				for ( my $i=$start; $i <= $stop; $i++ )	{
					my @key = grep { $_ =~ /^$i/ } keys %Tiers;
					$Tiers{$key[0]} = 1;
				}
			}
			else	{
				my @key = grep { $_ =~ /^$config/ } keys %Tiers;
				$Tiers{$key[0]} = 1;
			}
		}
	}
}
# Otherwise, assume we just want the distances from one binding site to the next
else	{
	$Tiers{0} = 1;
}
# The following algorithm only wants the tiers we are goign to use, so for expediency, delete the ones we dont want here.
foreach ( keys %Tiers )	{
	delete $Tiers{$_} if ( $Tiers{$_} == 0 );
}
###################################################################

# Get the set of contig/chromosome intervals
my $total_length = get_fasta_length( $genome_fasta );

# Open the output and print the header line
print STDERR " === KMER K50 :: Processing K50 scores === \n" if ( $v == 1 );
my $succout = open(OUT, ">", "$output.K$percentage.tab") if ( $output ne "--" );
if ( $succout ) 	{ 	print OUT    "Set#\tTier\tK50\tNSites\tBreadth\tKmers\tBindingSites\n";		}
else				{	print STDOUT "Set#\tTier\tK50\tNSites\tBreadth\tKmers\tBindingSites\n";		}

###################################################################
for ( my $i=0; $i < scalar @sets; $i++ )	{
	# Generate the subset
	my %Set = ();
	my $name = $names[$i];
	foreach ( @{$sets[$i]} )	{
		if ( not exists $BindingSites{$_} )	{
			warn " === KMER K50 Warning :: A kmer ( $_ ) in the process of being evaluated isn't present in the binding sites list given! === \n";
			$name = "$name*" if ( $name !~ /\*$/ );
			next;
		}
		$Set{$_} = $BindingSites{$_};
	}
	
	# The @kmers array should be the order of the kmers sorted by the number of binding sites they represent, in descending order.
	my @kmers = sort { scalar @{$Set{$b}} <=> scalar @{$Set{$a}} } keys %Set;

	# Move through the @kmers array, and set a flag when we hit 50% coverage over the total length
	# Foreach kmer element, calculate the sum total of the tiered interval size
	foreach my $tier ( sort {$a <=> $b } keys %Tiers ) 	{
		my $breadth = 0;
		my @k50;
		my @k50_sites;
		
		foreach my $kmer ( @kmers )		{
			my @sites = @{$Set{$kmer}};
			# Calculate the tiered intervals from the max range and standard deviation.
			# The tiers progress from lowest confidence (tier 3) up to highest (tier 1), where the tier is the number of standard deviations from the binding site 'mean'.  
			my %Intervals = ();
			for ( my $i=0; $i < scalar @sites; $i++ )	{
				my $site = $sites[$i];

				# The start site for each interval (the hash key) is the greater of either the starting position of the interval or 0, the beginning of the genome.
				# The ending site of the interval, the hash value, is the lesser of either the interval's ending position or the maximum position in the genome.
				my $start_site = ($site - ($tier*$sd) > 0)? $site - ($tier*$sd) : 0;
				$Intervals{$start_site} = (($site + ($tier*$sd)) < $total_length )? ($site + ($tier*$sd)) : $total_length;
			}
				
			# Sort the %Intervals by START site and use that sorted list to compute the overlap between sites.
			my @starting_sites = sort { $a <=> $b } keys %Intervals;
			
			# Initialize the bases covered with the size of the first interval (which cannot overlap with anything else).
			my $bases_covered = $Intervals{ $starting_sites[0] } - $starting_sites[0];
			
			# The loop to calculate the overlaps.
			# The current interval starting position minus the previous interval's ending position is the overlap.
			# For each iteration, add the width of the current interval, minus any overlap with the previous interval to the sum of bases covered.
			for ( my $i=1; $i < scalar @starting_sites; $i++ )	{
				my $overlap = ( $starting_sites[$i] - $Intervals{$starting_sites[$i-1]} < 0 )? abs($starting_sites[$i] - $Intervals{$starting_sites[$i-1]}) : 0;
				$bases_covered += (($Intervals{ $starting_sites[$i] } - $starting_sites[$i]) - $overlap);
			}
			
			# Finally, compute the expected breadth coverage, as a percentage of the genome length covered by non-overlapping intervals.
			$breadth += sprintf("%5.2f", 100 *  ( $bases_covered / $total_length ));
			
			# If the breadth is less than 50, add things to the growing lists, otherwise break this loop
			if ( $breadth < $percentage )	{	push @k50, $kmer;	@k50_sites = ( @k50_sites, @sites );		}
			else 							{	last;															}
		}
		# Print the results out for each tier, for each set of binding sites
		@k50_sites = sort {$a <=> $b} @k50_sites;
		if ( $succout ) 	{	print OUT    "$name\t$tier\t", scalar @k50, "\t", scalar @k50_sites, "\t$breadth\t", join(",", @k50), "\t", join(",", @k50_sites), "\n";		}
		else				{	print STDOUT "$name\t$tier\t", scalar @k50, "\t", scalar @k50_sites, "\t$breadth\t", join(",", @k50), "\t", join(",", @k50_sites), "\n";		}
	}
}
###################################################################

exit;

########################## SUBROUTINES ##############################

# Read an input fasta file and return a 
sub get_fasta_length		{
	my ( $file ) = @_;
	
	# Read the data
	my @fastas;
	$/ = ">";
	open FASTA, "$file" or die " ==== KMER COVERAGE Error :: Cannot read the given Fasta file! ===\n$!\n";
		@fastas = <FASTA>;
		my $trash = shift @fastas;	# Get rid of the first element, which will be a lone ">" symbol
	$/ = "\n";

	my $total_length = 0;
	foreach my $record ( @fastas )	{
		my ($header, @seq) = split "\n", $record;
		my $sequence = join '', @seq;
		$total_length += length $sequence;
	}
	return $total_length; 
}
